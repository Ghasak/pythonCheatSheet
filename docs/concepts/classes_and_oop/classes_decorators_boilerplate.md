## Intro

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Intro](#intro)
- [Regular classes as  BolierPlate ](#regular-classes-as--bolierplate)
- [DataClass as a Boilerplate](#dataclass-as-a-boilerplate)
    - [Key Features of the Boilerplate:](#key-features-of-the-boilerplate)
    - [1. Boilerplate with Abstract Classes and Decorators](#1-boilerplate-with-abstract-classes-and-decorators)
    - [2. Decorator to Measure Function Execution Time](#2-decorator-to-measure-function-execution-time)
    - [Explanation:](#explanation)

<!-- markdown-toc end -->




## Regular classes as  BolierPlate 

```python
class Item:
    count = 0  # Class variable to track the number of objects

    def __init__(self, name, value):
        self._name = name  # Object variable
        self._value = value  # Object variable
        Item.count += 1
        self._id = Item.count  # Unique identifier for each object

    def __str__(self):
        return f"Item({self._name}, {self._value})"

    def __repr__(self):
        return f"{self.__class__.__name__}(name={self._name}, value={self._value}, id={self._id})"

    def __eq__(self, other):
        if isinstance(other, Item):
            return self._value == other._value and self._name == other._name
        return False

    def __lt__(self, other):
        if isinstance(other, Item):
            return self._value < other._value
        return NotImplemented

    def __le__(self, other):
        return self < other or self == other

    def __gt__(self, other):
        return not self <= other

    def __ge__(self, other):
        return not self < other

    def __hash__(self):
        return hash((self._name, self._value, self._id))

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        if value < 0:
            raise ValueError("Value cannot be negative.")
        self._value = value

    @classmethod
    def how_many(cls):
        return f"There are currently {cls.count} items."

    @staticmethod
    def get_extension():
        return 'txt'  # Simplified for example; modify according to your need

    def update_value(self, new_value):
        self.value = new_value  # Utilizes the setter

    @property
    def info(self):
        return f"Item ID: {self._id}, Name: {self.name}, Value: {self.value}"

    # Use this method if inheriting to ensure superclass initialization is handled correctly
    def initialize_superclass(self):
        super().__init__()

# Usage:
item1 = Item("Book", 150)
item2 = Item("Pen", 5)
print(item1)  # Uses __str__
print(repr(item2))  # Uses __repr__
print(item1 > item2)  # True, because 150 > 5
print(Item.how_many())  # Outputs the count of created Item instances

```
## DataClass as a Boilerplate

Sure, using `dataclasses` from Python's standard library can simplify class
definition while still supporting a rich feature set. Below is a comprehensive
boilerplate example using a `dataclass` that includes most of the features
you've requested, such as handling initialization, comparison, hashing,
ordering, and setting default values with both `default` and `default_factory`.

```python
from dataclasses import dataclass, field, InitVar
from typing import ClassVar

@dataclass(order=True, frozen=True)
class Item:
    # Class variable to track the number of objects
    count: ClassVar[int] = 0

    # Fields
    name: str
    value: int
    _id: int = field(init=False, repr=True)  # This field will not be included in the constructor, but will be shown in __repr__
    
    # Fields that use default_factory and default
    category: str = field(default="General")
    description: str = field(default_factory=lambda: "No description provided")

    # InitVar for temporary processing
    temp_process: InitVar[bool] = False

    def __post_init__(self, temp_process):
        # This runs after the default __init__ generated by dataclass
        object.__setattr__(self, '_id', Item.count + 1)  # Assign a unique ID
        Item.count += 1  # Increment the count of created instances
        
        if temp_process:
            # Example processing; can be customized
            self.process_temp()

    def process_temp(self):
        # Example method that could be called during post-init
        print(f"Processing {self.name}")

    @property
    def info(self):
        # Example of a method turned into a property
        return f"Item ID: {self._id}, Name: {self.name}, Value: {self.value}"

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        object.__setattr__(self, '_name', value)

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        if value < 0:
            raise ValueError("Value cannot be negative.")
        object.__setattr__(self, '_value', value)

    @classmethod
    def how_many(cls):
        # Class method to return the count of items
        return f"There are currently {cls.count} items."

    @staticmethod
    def get_extension():
        # Static method to get file extension
        return 'txt'  # Just a placeholder

# Usage:
item1 = Item("Book", 150)
item2 = Item("Pen", 5)
print(item1)  # Uses __str__ from the dataclass
print(repr(item2))  # Uses __repr__ from the dataclass
print(item1 > item2)  # True, because 150 > 5
print(Item.how_many())  # Outputs the count of created Item instances
print(item1.info)  # Accesses the property
```

### Key Features of the Boilerplate:
- **@dataclass Decorator**: Simplifies class definition and automatically adds
  special methods like `__init__`, `__repr__`, `__eq__`, and others depending on
  the parameters (`order=True` adds ordering methods, `frozen=True` makes it
  immutable).
- **ClassVar**: Used for the `count` variable that shouldn't be considered a
  field of individual instances.
- **field()**: Used to modify the behavior of dataclass fields, like excluding
  `_id` from `__init__` and making it part of `__repr__`.
- **InitVar**: Used for parameters that are part of the initialization process
  but not stored as fields.
- **__post_init__**: Method called after the automatic `__init__` method where
  you can add custom initialization logic.
- **Properties and Setters**: Custom properties with setters even in a frozen
  dataclass using `object.__setattr__`.

This example can be used as a starting point for creating other classes by
modifying field types, adding methods, or changing properties. It provides a
solid base for a variety of applications and can be extended or adapted as
needed.



### 1. Boilerplate with Abstract Classes and Decorators

Here is a boilerplate example demonstrating the use of abstract classes along with decorators in Python. This example includes key concepts like inheritance, method overriding, and custom decorators.

```python
from abc import ABC, abstractmethod
from functools import wraps

def my_custom_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Before executing {func.__name__}")
        result = func(*args, **kwargs)
        print(f"After executing {func.__name__}")
        return result
    return wrapper

class AbstractBaseClass(ABC):
    
    @abstractmethod
    def do_something(self):
        """
        Abstract method that should do something.
        """
        pass

    @my_custom_decorator
    def public_method(self):
        """
        A public method that calls the abstract method.
        """
        print("This is a public method.")
        self.do_something()

class ConcreteClass(AbstractBaseClass):
    def do_something(self):
        """
        Implementation of the abstract method.
        """
        print("Doing something important in the ConcreteClass.")

# Usage
concrete_instance = ConcreteClass()
concrete_instance.public_method()
```



This boilerplate uses:
- **ABC and abstractmethod**: To define an abstract base class and ensure that
  derived classes implement specific methods (`do_something` in this case).
- **Custom Decorator `my_custom_decorator`**: Adds functionality before and
  after the execution of methods it decorates, demonstrated here on the
  `public_method`.
- **Concrete Implementation**: `ConcreteClass` that inherits from
  `AbstractBaseClass` and implements the abstract method.

### 2. Decorator to Measure Function Execution Time

For measuring the execution time more accurately than `time.time()`, you can use
`time.perf_counter()`, which provides a higher resolution timer, ideal for
measuring short durations. Here's an example:

```python
import time
from functools import wraps

def timeit(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        print(f"{func.__name__} executed in {end_time - start_time:.8f} seconds")
        return result
    return wrapper

@timeit
def example_function(n):
    """
    Example function that sums the range from 0 to n-1
    """
    return sum(range(n))

# Usage
result = example_function(1000000)
```

### Explanation:

- **timeit Decorator**: Wraps any function, capturing the start and end times
  around its execution using `time.perf_counter()`, which is more precise than
  `time.time()`.
- **@wraps**: Utilized from `functools` to preserve the wrapped function's
  metadata (like its name and docstring).
- **Usage Example**: `example_function` simply sums numbers from `0` to `n-1` to
  give a simple example of a time-consuming operation.

These boilerplates can be adapted or expanded based on specific requirements,
providing a robust foundation for using abstract classes and decorators to
structure and enhance Python applications.
